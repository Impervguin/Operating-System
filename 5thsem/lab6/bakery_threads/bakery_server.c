/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "bakery.h"
#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include<math.h>




int choosing[PROC_COUNT] = {0};
int number[PROC_COUNT] = {0};

bool_t
get_number_1_svc(struct BAKERY_CALCULATOR *argp, struct BAKERY_CALCULATOR *result, struct svc_req *rqstp)
{
	*result = *argp;
	bool_t retval;
	int i = argp->index;
	pthread_mutex_lock(&choosing_mutex);
	if (number[i] != 0) {
		pthread_mutex_unlock(&choosing_mutex);
		return FALSE;
	}
	choosing[i] = TRUE;
	int max = 0;
	for (int j = 0; j < PROC_COUNT; j++) {
		if (number[j] > max)
            max = number[j];
	}
	number[i] = max + 1;
	choosing[i] = 0;

	pthread_mutex_unlock(&choosing_mutex);
	result->num = number[i];
	result->index = i;
	return TRUE;
}

bool_t
perform_1_svc(struct BAKERY_CALCULATOR *argp, struct BAKERY_CALCULATOR *result, struct svc_req *rqstp)
{
	setbuf(stdout, NULL);
	bool_t retval;
	*result = *argp;

	for (int i = 0; i < PROC_COUNT; i++) {
		while (choosing[i]);
		while (number[i] > 0 && (number[i] < number[argp->index] || (number[i] == number[argp->index] && i <argp->index)));
	}
	switch (argp->op)
	{
	case ADD:
		result->result = argp->arg1 + argp->arg2;
		break;
	case SUB:
	    result->result = argp->arg1 - argp->arg2;
		break;
	case MUL:
	    result->result = argp->arg1 * argp->arg2;
		break;
	case DIV:
	    if (fabs(argp->arg2) < 1e-15)
		{
			printf("%d %f\n", result->op, result->arg2);
            result->op = -1;
            break;
        }
		result->result = argp->arg1 / argp->arg2;
		break;
	default:
	    result->op = -1;
		break;
	}
	
	usleep(300);
	number[argp->index] = 0;
	return TRUE;
}

int
bakery_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);
	return 1;
}
