/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "bakery.h"
#include <unistd.h>
#include <stdio.h>
#include<math.h>
#include <time.h>

int choosing[PROC_COUNT] = {0};
int number[PROC_COUNT] = {0};
int last_number = 0;
int last_index = 0;


struct BAKERY_CALCULATOR *
get_number_1_svc(struct BAKERY_CALCULATOR *argp, struct svc_req *rqstp)
{
	static struct BAKERY_CALCULATOR  result;
	result = *argp;
	int index = last_index;
	last_index++;

	choosing[index] = 1;
	int max = 0;
	for (int j = 0; j < PROC_COUNT; j++) {
		if (number[j] > max)
            max = number[j];
	}
	number[index] = max + 1;
	choosing[index] = 0;
	result.num = number[index];
	result.index = index;
	return &result;
}

struct BAKERY_CALCULATOR *
perform_1_svc(struct BAKERY_CALCULATOR *argp, struct svc_req *rqstp)
{
	static struct BAKERY_CALCULATOR  result;
	result = *argp;
	if (last_number > number[argp->index]) {
		result.num = -1;
		return &result;
	}

	for (int i = 0; i < PROC_COUNT; i++) {
		while (choosing[i]);

		time_t start = time(NULL);
		
		while (number[i] > last_number && (number[i] < number[argp->index] || (number[i] == number[argp->index] && i <argp->index)) 
			&& difftime(time(NULL), start) < 1);
	}
	switch (argp->op)
	{
	case ADD:
		result.result = argp->arg1 + argp->arg2;
		break;
	case SUB:
	    result.result = argp->arg1 - argp->arg2;
		break;
	case MUL:
	    result.result = argp->arg1 * argp->arg2;
		break;
	case DIV:
	    if (fabs(argp->arg2) < 1e-15)
		{
            result.op = -1;
            break;
        }
		result.result = argp->arg1 / argp->arg2;
		break;
	default:
	    result.op = -1;
		break;
	}

	last_number = number[argp->index];
	// number[argp->index] = 0;
	


	return &result;
}
