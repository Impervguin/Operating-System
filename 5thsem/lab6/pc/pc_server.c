/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "pc.h"

#include <sys/sem.h>

#define SEMAPHORE_EMPTY 0
#define SEMAPHORE_FULL 1
#define SEMAPHORE_BINARY 2

#define p -1
#define v 1

struct sembuf start_consume[] = {{SEMAPHORE_FULL, p, 0}, {SEMAPHORE_BINARY, p, 0}};
struct sembuf end_consume[] = {{SEMAPHORE_BINARY, v, 0}, {SEMAPHORE_EMPTY, v, 0}};

struct sembuf start_produce[] = {{SEMAPHORE_EMPTY, p, 0}, {SEMAPHORE_BINARY, p, 0}};
struct sembuf end_produce[] = {{SEMAPHORE_BINARY, v, 0}, {SEMAPHORE_FULL, v, 0}};

#define BUFFER_SIZE 1000
char *buf;
char *current_consume;
char *current_produce;
char next_letter;
int semid;

int init_pc() {
	buf = malloc(sizeof(char) * BUFFER_SIZE);
	if (buf == NULL) {
        perror("malloc");
        return 1;
    }
	current_consume = buf;
	current_produce = buf;
	next_letter = 'a';
	
	semid = semget(IPC_PRIVATE, 3, IPC_CREAT | 0666);
    if (semid == -1) {
        perror("semget");
        return 1;
    }

    if (semctl(semid, SEMAPHORE_EMPTY, SETVAL, BUFFER_SIZE) == -1) {
        perror("semctl");
        return 1;
    }
    if (semctl(semid, SEMAPHORE_BINARY, SETVAL, 1) == -1) {
        perror("semctl");
        return 1;
    }
    if (semctl(semid, SEMAPHORE_FULL, SETVAL, 0) == -1) {
        perror("semctl");
        return 1;
    }
	return 0;
}

bool_t
consume_1_svc(void *argp, char *result, struct svc_req *rqstp)
{
	bool_t retval;

	
	int err = semop(semid, start_consume, 2);
	if (err == -1) {
		perror("semop\n");
		exit(1);
	}

	*result = *current_consume;
	current_consume++;
	if (current_consume - buf == BUFFER_SIZE) {
		current_consume = buf;
	}

	err = semop(semid, end_consume, 2);
	if (err == -1) {
		perror("semop\n");
		exit(1);
	}

	return TRUE;
}

bool_t
produce_1_svc(void *argp, char *result, struct svc_req *rqstp)
{
	bool_t retval;

	int err = semop(semid, start_produce, 2);
	if (err == -1) {
		perror("semop\n");
		exit(1);
	}

	*current_produce = next_letter;
	*result = next_letter;
	next_letter++;
	if (next_letter > 'z') {
        next_letter = 'a';
    }
	current_produce++;
	if (current_produce - buf == BUFFER_SIZE) {
		current_produce = buf;
	}

	err = semop(semid, end_produce, 2);
	if (err == -1) {
		perror("semop\n");
		exit(1);
	}

	return TRUE;
}

int
pc_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
